# 南宁理工学院听课评教系统开发指南

## 概述

本指南为开发团队成员提供详细的开发实践说明，包括权限控制、配置使用、API开发等关键内容。

## 权限控制系统

### 权限验证装饰器

系统提供了多种权限验证方式，开发者可以根据需要选择合适的方式。

#### 方式1：路由级别声明（不需要在函数参数中使用）
```python
@router.get("/users", dependencies=[Depends(require_permissions("user:read"))])
async def list_users():
    # 仅验证权限，不直接使用 current_user
    ...
```

#### 方式2：参数注入（可以同时获取 current_user）
```python
@router.post("/users")
async def create_user(
    current_user: TokenData = Depends(require_permissions("user:create"))
):
    # current_user 已验证并可用
    # 可以访问 current_user.id, current_user.user_on 等属性
    ...
```

#### 方式3：角色验证（满足任一角色）
```python
@router.delete("/users/{id}")
async def delete_user(
    current_user: TokenData = Depends(require_roles("admin", "super_admin"))
):
    # 用户具有 admin 或 super_admin 角色之一即可访问
    ...
```

#### 方式4：需要全部权限
```python
@router.put("/users/{id}")
async def update_user(
    _: None = Depends(require_permissions("user:read", "user:update", require_all=True))
):
    # 需要同时具有 user:read 和 user:update 权限
    ...
```

### 权限验证函数

#### require_permissions - 权限验证
```python
def require_permissions(*permission_codes: str, require_all: bool = False):
    """
    验证用户权限
    :param permission_codes: 权限代码列表
    :param require_all: 是否需要满足所有权限，默认为 False（满足任一权限即可）
    :return: 验证通过返回当前用户信息，否则抛出 HTTPException
    """
```

#### require_roles - 角色验证
```python
def require_roles(*role_codes: str):
    """
    验证用户角色
    :param role_codes: 角色代码列表
    :return: 验证通过返回当前用户信息，否则抛出 HTTPException
    """
```

### 权限验证示例

```python
from fastapi import APIRouter, Depends
from app.core.deps import require_permissions, require_roles
from app.schemas import TokenData

router = APIRouter()

# 需要 read:evaluation 权限
@router.get("/evaluations", dependencies=[Depends(require_permissions("read:evaluation"))])
async def get_evaluations():
    return {"message": "获取评价列表"}

# 需要 create:evaluation 权限，同时获取当前用户信息
@router.post("/evaluations")
async def create_evaluation(
    current_user: TokenData = Depends(require_permissions("create:evaluation"))
):
    # 可以使用 current_user 的信息
    return {"message": f"用户 {current_user.user_name} 创建评价"}

# 需要 admin 或 teacher 角色
@router.delete("/evaluations/{id}")
async def delete_evaluation(
    current_user: TokenData = Depends(require_roles("admin", "teacher"))
):
    return {"message": "删除评价成功"}

# 需要同时具有 read:evaluation 和 delete:evaluation 权限
@router.put("/evaluations/{id}")
async def update_evaluation(
    _: None = Depends(require_permissions("read:evaluation", "update:evaluation", require_all=True))
):
    return {"message": "更新评价成功"}
```

## 配置系统 (config.py)

### 配置文件结构

配置文件位于 [app/core/config.py](file:///D:/teaching-evaluation-system/backend/app/core/config.py)，使用环境变量进行配置。

### 配置项说明

```python
# 数据库配置
MYSQL_USER = os.getenv("MYSQL_USER")          # 数据库用户名
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD")  # 数据库密码
MYSQL_HOST = os.getenv("MYSQL_HOST")          # 数据库主机
MYSQL_PORT = os.getenv("MYSQL_PORT")          # 数据库端口
MYSQL_DB = os.getenv("MYSQL_DB")              # 数据库名

# JWT 配置
SECRET_KEY = os.getenv("SECRET_KEY")          # JWT 密钥
ALGORITHM = os.getenv("ALGORITHM")            # JWT 算法
ACCESS_TOKEN_EXPIRE_MINUTES = os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES")  # Token 过期时间（分钟）

# 应用配置
APP_NAME = os.getenv("APP_NAME")              # 应用名称
APP_VERSION = os.getenv("APP_VERSION")        # 应用版本
DEBUG = os.getenv("DEBUG")                    # 调试模式
```

### 环境变量配置

在项目根目录创建 `.env` 文件：

```bash
# 应用配置
APP_NAME=Teaching Evaluation System
APP_VERSION=1.0.0
DEBUG=True

# 数据库配置
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=your_db_user
MYSQL_PASSWORD=your_db_password
MYSQL_DB=teaching_evaluation

# JWT 配置
SECRET_KEY=your_very_long_secret_key_here_must_be_at_least_32_characters_long
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
```

### 在代码中使用配置

```python
from app.core.config import MYSQL_HOST, MYSQL_PORT, SECRET_KEY

# 直接使用配置值
print(f"数据库主机: {MYSQL_HOST}:{MYSQL_PORT}")
print(f"JWT密钥: {SECRET_KEY}")
```

## API 开发实践

### Request 对象的使用

在 FastAPI 中，`Request` 对象提供了对 HTTP 请求的完全访问。

```python
from fastapi import Request

@router.get("/example")
async def example_endpoint(request: Request):
    # 获取请求方法
    method = request.method
    
    # 获取请求URL
    url = str(request.url)
    
    # 获取请求头
    user_agent = request.headers.get("user-agent")
    authorization = request.headers.get("authorization")
    
    # 获取客户端IP
    client_host = request.client.host
    
    # 获取查询参数
    query_params = dict(request.query_params)
    
    return {
        "method": method,
        "url": url,
        "user_agent": user_agent,
        "client_ip": client_host,
        "query_params": query_params
    }
```

### TokenData 的使用

`TokenData` 包含了验证通过的用户信息：

```python
from app.schemas import TokenData
from app.core.deps import get_current_user

@router.get("/user-info")
async def get_user_info(
    current_user: TokenData = Depends(get_current_user)
):
    return {
        "user_id": current_user.id,
        "user_on": current_user.user_on,      # 工号/账号
        "college_id": current_user.college_id,  # 学院ID
        "status": current_user.status,        # 用户状态
        "is_delete": current_user.is_delete   # 是否删除
    }
```

### API 开发模板

```python
from fastapi import APIRouter, Depends, Request
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.schemas import BaseResponse, TokenData
from app.core.deps import get_current_user, require_permissions

router = APIRouter(prefix="/example", tags=["示例"])

# 不需要认证的公开接口
@router.post("/public-endpoint")
async def public_endpoint():
    """
    公开接口示例
    不需要认证即可访问
    """
    return BaseResponse(
        code=200,
        msg="success",
        data={"message": "这是公开接口"}
    )

# 需要认证的接口
@router.get("/protected-endpoint")
async def protected_endpoint(
    current_user: TokenData = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    需要认证的接口示例
    """
    return BaseResponse(
        code=200,
        msg="success",
        data={
            "user_id": current_user.id,
            "user_name": current_user.user_on
        }
    )

# 需要特定权限的接口
@router.post("/admin-endpoint", dependencies=[Depends(require_permissions("admin:access"))])
async def admin_endpoint(
    request: Request,
    current_user: TokenData = Depends(get_current_user)
):
    """
    需要特定权限的接口示例
    """
    return BaseResponse(
        code=200,
        msg="success",
        data={
            "user_id": current_user.id,
            "user_name": current_user.user_on,
            "ip_address": request.client.host
        }
    )

# 同时使用 Request 和权限验证
@router.put("/mixed-endpoint")
async def mixed_endpoint(
    request: Request,
    current_user: TokenData = Depends(require_permissions("user:update"))
):
    """
    结合 Request 和权限验证的接口示例
    """
    # 从请求体获取数据
    body = await request.json()
    
    return BaseResponse(
        code=200,
        msg="success",
        data={
            "user_id": current_user.id,
            "request_method": request.method,
            "request_body": body
        }
    )
```

## 数据库操作

### 异步数据库会话

使用 `get_db` 依赖注入获取数据库会话：

```python
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db

@router.get("/users")
async def get_users(db: AsyncSession = Depends(get_db)):
    # 使用 db 进行数据库操作
    # ...
    pass
```

### CRUD 操作

在 [app/crud/](file:///D:/teaching-evaluation-system/backend/app/crud/) 目录下创建 CRUD 操作：

```python
# app/crud/your_module.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.models import YourModel

async def get_items(db: AsyncSession, skip: int = 0, limit: int = 100):
    """获取项目列表"""
    result = await db.execute(select(YourModel).offset(skip).limit(limit))
    return result.scalars().all()

async def get_item(db: AsyncSession, item_id: int):
    """根据ID获取单个项目"""
    result = await db.execute(select(YourModel).where(YourModel.id == item_id))
    return result.scalar_one_or_none()

async def create_item(db: AsyncSession, item_data: dict):
    """创建新项目"""
    db_item = YourModel(**item_data)
    db.add(db_item)
    await db.commit()
    await db.refresh(db_item)
    return db_item
```

## Pydantic 模型使用

### 请求模型

```python
from pydantic import BaseModel

class ItemCreate(BaseModel):
    name: str
    description: str
    value: int

class ItemUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    value: int | None = None
```

### 响应模型

```python
class ItemResponse(BaseModel):
    id: int
    name: str
    description: str
    value: int
    
    class Config:
        from_attributes = True  # 允许从 ORM 对象创建模型
```

### 统一响应格式

使用 [BaseResponse](file:///D:/teaching-evaluation-system/backend/app/schemas.py#L21-L32) 作为统一响应格式：

```python
from app.schemas import BaseResponse

@router.get("/items/{item_id}")
async def get_item(item_id: int):
    # 获取数据
    item = await get_item_from_db(item_id)
    
    if not item:
        return BaseResponse(
            code=404,
            msg="Item not found",
            data=None
        )
    
    return BaseResponse(
        code=200,
        msg="success",
        data=item
    )
```

## 中间件和认证

### 认证中间件

系统使用 [AuthMiddleware](file:///D:/teaching-evaluation-system/backend/app/middleware/auth_middleware.py#L7-L71) 自动处理认证：

- 公共路径（无需认证）：
  - `/`
  - `/health`
  - `/health/db`
  - `/api/v1/teaching-eval/user/login`
  - `/api/v1/teaching-eval/user/register`

- 需要认证的路径会自动验证 JWT Token

### Token 处理

登录和注册接口会自动设置 Token Cookie：

```python
def set_token_in_response(request: Request, user):
    """
    在响应中设置token
    :param request: 请求对象
    :param user: 用户对象
    """
    token_obj = create_access_token(TokenData(
        id=user.id,
        user_on=user.user_on,
        college_id=user.college_id,
        status=user.status,
        is_delete=user.is_delete
    ))
    request.state.token_to_set = token_obj.token
```

## 错误处理

### HTTP 异常

```python
from fastapi import HTTPException

@router.get("/items/{item_id}")
async def get_item(item_id: int):
    item = await get_item_from_db(item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    return item
```

### 统一异常处理

系统提供统一的异常处理机制，包括：
- HTTP 异常处理
- 验证异常处理
- 通用异常处理

## 测试实践

### 单元测试结构

```python
# tests/test_your_feature.py
import pytest
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_create_item():
    response = client.post("/api/items", json={
        "name": "Test Item",
        "description": "Test Description",
        "value": 100
    })
    assert response.status_code == 200
    data = response.json()
    assert data["code"] == 200
    assert data["data"]["name"] == "Test Item"
```

## 最佳实践

### 1. 权限验证
- 总是对需要权限的接口进行验证
- 使用适当的权限验证方式
- 避免在函数内部进行权限验证

### 2. 数据验证
- 使用 Pydantic 模型进行数据验证
- 在函数参数中明确指定类型
- 使用适当的响应模型

### 3. 错误处理
- 使用 HTTPException 抛出适当的状态码
- 提供有意义的错误消息
- 使用统一的响应格式

### 4. 数据库操作
- 使用异步数据库操作
- 正确处理事务
- 使用适当的查询方法

### 5. 代码组织
- 将 API 路由放在 [app/api/](file:///D:/teaching-evaluation-system/backend/app/api/) 目录
- 将数据库操作放在 [app/crud/](file:///D:/teaching-evaluation-system/backend/app/crud/) 目录
- 将模型定义放在 [app/models.py](file:///D:/teaching-evaluation-system/backend/app/models.py) 和 [app/schemas.py](file:///D:/teaching-evaluation-system/backend/app/schemas.py)
- 将核心功能放在 [app/core/](file:///D:/teaching-evaluation-system/backend/app/core/) 目录